//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 技术平台公共类库 区域读写锁
//  @ File Name : carealock.cpp
//  @ Date : 2013/6/20
//  @ Author : disp
//
//

#include "platspub.h"
#include "arealock.h"

CAreaLock::CAreaLock()
{
	m_nSemId = -1;
}

CAreaLock::~CAreaLock()
{

}

int CAreaLock::Create(key_t key)
{
		int nSemId = semget(key,2,0660|/*IPC_EXCL|*/IPC_CREAT);
		if(nSemId == -1)
		{
				PINFO("create AreaLock error: %s", strerror(errno));		
			
		}
		else
		{
				union semun semopts;
				semopts.val = MULTI_INIT; //0
				semctl(nSemId,AREA_READ_SEM,SETVAL,semopts);
				semopts.val = BINARY_INIT;//1
				semctl(nSemId,AREA_UPDATE_SEM,SETVAL,semopts);
			}
				
		m_nSemId = nSemId;
		return nSemId;


}

int CAreaLock::Select(key_t key)
{
	//printf("[CAreaLock] g_nLogLevel = %d\n" , GetLogLevel() );	
			
	int nSemId = semget(key,2,0);
	if(nSemId == -1)
	{
		PINFO("select AreaLock error: %s", strerror(errno));		
		printf("select AreaLock error: %s \n", strerror(errno));		
	}
	
	m_nSemId = nSemId;
	return nSemId;
}

int CAreaLock::LockUpdate()
{
	if(m_nSemId==-1)
		return -100;
			
	struct sembuf sops[2];
	sops[0].sem_num = AREA_UPDATE_SEM;
	sops[0].sem_op = LOCK_BINARY;
	sops[0].sem_flg = SEM_UNDO;
	if(semop(m_nSemId,&sops[0],1)==0)
	{
		sops[0].sem_num = AREA_READ_SEM;
	    sops[0].sem_op = EMPTY_MULTI;
	    sops[0].sem_flg = SEM_UNDO;
	    if(semop(m_nSemId,&sops[0],1)==0)
	    	return 0;
	}
	
	return -1;
	    
	
}

int CAreaLock::LockRead()
{
		if(m_nSemId==-1)
			return -100;
			
		struct sembuf sops[2];
		sops[0].sem_num = AREA_UPDATE_SEM;
		sops[0].sem_op = LOCK_BINARY;
		sops[0].sem_flg = SEM_UNDO;
		if(semop(m_nSemId,&sops[0],1)==0)
		{
				sops[0].sem_num = AREA_UPDATE_SEM;
		    sops[0].sem_op = UNLOCK_BINARY;
		    sops[0].sem_flg = SEM_UNDO;
		    sops[1].sem_num = AREA_READ_SEM;
		    sops[1].sem_op = LOCK_MULTI;
		    sops[1].sem_flg = SEM_UNDO;
	
		    if(semop(m_nSemId,&sops[0],2)==0)
		    	return 0;
		}
	
	return -1;
}

int CAreaLock::UnlockUpdate()
{
		if(m_nSemId==-1)
			return -100;
			
		struct sembuf sops[2];
		sops[0].sem_num = AREA_UPDATE_SEM;
		sops[0].sem_op = UNLOCK_BINARY;
		sops[0].sem_flg = SEM_UNDO;
		return semop(m_nSemId,&sops[0],1);

}

int CAreaLock::UnlockRead()
{
		if(m_nSemId==-1)
			return -100;
			
		struct sembuf sops[2];
		sops[0].sem_num = AREA_READ_SEM;
		sops[0].sem_op = UNLOCK_MULTI;
		sops[0].sem_flg = SEM_UNDO;
		return semop(m_nSemId,&sops[0],1);
}

int CAreaLock::Destroy()
{
		if(m_nSemId==-1)
			return -100;
			
		return semctl(m_nSemId,0,IPC_RMID);
}

int CAreaLock::TryWait(int num, int block)
{
		if(m_nSemId==-1)
			return -100;
			
		struct sembuf sbuf;
		sbuf.sem_num 	= num;
		sbuf.sem_op 	= 0;
		sbuf.sem_flg 	= (block ? SEM_UNDO : SEM_UNDO|IPC_NOWAIT);
		return semop(m_nSemId,&sbuf,1);	
}

