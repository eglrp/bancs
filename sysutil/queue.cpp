//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 技术平台公共类库 消息队列
//  @ File Name : queue.cpp
//  @ Date : 2013/6/6
//  @ Author : disp
//
//

#include "platspub.h"
#include "queue.h"


CQueue::CQueue() 
{
		m_nQueueId = -1;

}

CQueue::~CQueue()
{
	
}

int CQueue::CreateQueue(key_t key, int flag)
{
		int mqid = msgget(key, flag);
		
		if(mqid == -1)
		{
			
			PINFO("create queue error: %s\n", strerror(errno));
			
			/*
			if(errno == EEXIST)
			{
				mqid = msgget(key, 0);
				if(mqid == -1)
				{
					PERROR("get queue error: %s", strerror(errno));
					exit(1);
				}
		
				if(msgctl(mqid, IPC_RMID, NULL) == -1)
				{
					PERROR("remove queue error: %s", strerror(errno));
					exit(1);
				}
		
				mqid = msgget(key, flag);
				if(mqid == -1)
				{
					PERROR("recreate queue error: %s", strerror(errno));
					exit(1);
				}
			}
			else
			{
				PERROR("create queue error: %s", strerror(errno));
			}
			*/
			
		}
		
		m_nQueueId = mqid;
		
		return mqid;
	
}

int CQueue::SelectQueue(key_t key)
{
		int mqid = msgget(key, 0);
		if(mqid == -1)
		{
			//PERROR("get queue error: %s\n", strerror(errno));
		}
		
		m_nQueueId = mqid;
		
		return mqid;
				
}

int CQueue::SendMsg(void* data, int len)
{
		if(m_nQueueId == -1 || data==NULL)
			return -100;
			
		int nRet = msgsnd(m_nQueueId,data,len,0);
		//if(nRet == -1 && error == EINTR) //信号中断，重新发送一次
		//	nRet = msgsnd(m_nQueueId,data,len,0);
			
		if(nRet == -1)
			PERROR("msgsnd failed: %s\n", strerror(errno));	
		
		return nRet;		
			
}

int CQueue::SendMsg_NOWAIT(void* data, int len)
{
		if(m_nQueueId == -1 || data==NULL)
			return -100;
	
		int nRet = msgsnd(m_nQueueId,data,len,IPC_NOWAIT);
		if(nRet == -1)
			PERROR("msgsnd failed: %s\n", strerror(errno));	
		
		return nRet;
}

int CQueue::ReceiveMsg(void* data, int len, long type)
{
		if(m_nQueueId == -1 || data==NULL)
			return -100;
			
		int nRet = msgrcv(m_nQueueId,data,len,type,0);
		if(nRet == -1)
			PERROR("msgrcv failed: %s\n", strerror(errno));	
		
		return nRet;			
}

int CQueue::ReceiveMsg_NOWAIT(void* data, int len, long type)
{
		if(m_nQueueId == -1 || data==NULL)
			return -100;
			
		int nRet = msgrcv(m_nQueueId,data,len,type,IPC_NOWAIT);
		if(nRet == -1)
			PERROR("msgrcv failed: %s\n", strerror(errno));	
		
		return nRet;
}


/*  Alarm signal handling routine */
bool CQueue::m_bAlarmExpired = false;
void CQueue::SignalAlarmCatch(int sig)
{
    m_bAlarmExpired = true;
}
            
int CQueue::ReceiveMsg_TIME(void* data, int len, int timeout,long type)
{
    if(m_nQueueId == -1 || data==NULL)
    	return -100;
    	
    m_bAlarmExpired = false;                /* Clear local alarm flag */
    signal(SIGALRM, SignalAlarmCatch);      /* Enable Alarm signal */
    alarm(timeout<2 ? 2: timeout);	        /* set the timeout */
    	
    int nRet = msgrcv(m_nQueueId,data,len,type,0);
    if (nRet == -1) 
    {
		PERROR("msgrcv failed: %s\n", strerror(errno));	
        if (m_bAlarmExpired) 
        {
            PDEBUG("Alarm fired, timeout processing\n");
            //memset(data,0,len);	
            return 0;//-2;  /* avoid completion processing  */
        } 
        else 
        {
            /* Other error, turn alarm off */
            alarm(0);
            signal (SIGALRM, SIG_DFL);  /* Restore default handler */
        }
    } 
    else 
    {
        alarm(0);                   /* Reply OK, turn alarm off */
        signal(SIGALRM, SIG_DFL);   /* Restore default handler */
    }		
		
	return nRet;
	
}

   
int CQueue::PrintStat()
{
		if(m_nQueueId == -1 )
			return -100;
				
		struct msqid_ds buf;
		memset(&buf,0,sizeof(buf));
		msgctl(m_nQueueId,IPC_STAT,&buf);
		PINFO("ID		KEY		CBYTES       QNUM       QBYTES");
		PINFO("%6d	%#10.8x %10d  %10d    %10d",
				m_nQueueId,
				buf.msg_perm.key,
				buf.msg_cbytes,
				buf.msg_qnum,
				buf.msg_qbytes);
		
		return 0;
}

int CQueue::GetStat(struct msqid_ds * pDs)
{
		if(m_nQueueId == -1 )
			return -100;
				
		memset(pDs,0,sizeof(struct msqid_ds));
		
		msgctl(m_nQueueId,IPC_STAT,pDs);
	
		return 0;	
}

int CQueue::CheckMsg(long type)
{
		if(m_nQueueId == -1)
			return -100;
		
		struct ncbs_msgbuf buf;
		int nRet = msgrcv(m_nQueueId,&buf,0,type,IPC_NOWAIT|MSG_NOERROR);
		
		return nRet;
}

int CQueue::DeleteQueue()
{
		if(m_nQueueId == -1)
			return -100;
			
		int nRet = msgctl(m_nQueueId, IPC_RMID, NULL);
		if(nRet ==0)
			m_nQueueId = -1;
		else if(nRet == -1)
		{
			PERROR("remove queue error: %s\n", strerror(errno));
		}
		
		return nRet;
}

