//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 技术平台公共类库 支持CDict消息队列
//  @ File Name : dictqueue.cpp
//  @ Date : 2013/6/13
//  @ Author : disp
//
//


#include "dictqueue.h"
#include "platspub.h"

CDictQueue::CDictQueue() 
{
		m_nQueueId = -1;

}

CDictQueue::~CDictQueue()
{
	
}

int CDictQueue::SendDict(CDict* pDict)
{
		if(m_nQueueId == -1 || pDict==NULL || !pDict->IsInitDict() )
			return -100;
			
		char  *pSendBuf = NULL;
		int nDictLen = pDict->SerializeDict();
		DictHandle hDict = pDict->GetHandle();
		
		struct ncbs_msgbuf head;
		head.mtype = MSGTYPE_DICT;
		
		if(nDictLen + sizeof(struct ncbs_msgbuf) <= MSGMAX)
		{
			pSendBuf = new char[nDictLen + sizeof(struct ncbs_msgbuf)];
			memcpy(pSendBuf, &head, sizeof(struct ncbs_msgbuf));
			memcpy(pSendBuf+sizeof(struct ncbs_msgbuf),hDict , nDictLen);
		}
		else //压缩
		{
			/*
			sendbuf = alloca(sizeof(mtyp_t) + sizeof(*imheader) + dictlen);
			compress_len = dictlen;
			if((ret = compress2(sendbuf + sizeof(mtyp_t) + sizeof(*imheader),
				&compress_len, *response, dictlen, Z_BEST_SPEED)) != Z_OK)
			{
				PERROR("compress2() error. return %d", ret);
				return -1;
			}
			PDEBUG("dictlen = [%d], compress_len = [%ld]", dictlen, compress_len);
			imheader->Length = dictlen = compress_len;
			imheader->MessageType = 1;
			memcpy(sendbuf + sizeof(mtyp_t), imheader, sizeof(*imheader));
			*((mtyp_t *)sendbuf)  = 1;
			*/
		}
		
		//长度不包含type，但数据内包含	
		int nRet = SendMsg(pSendBuf,nDictLen + sizeof(struct ncbs_msgdatabuf));
		if(pSendBuf)
			delete[] pSendBuf;

/*	
				printf("Dict Data:");				
				for(int m=0;m<400;m++)
				{
					if(m%40 ==0)
						printf("\n");
					printf("%02x ",((char*)hDict)[m]);
			
				}	
	*/
	
		return nRet;
			
}

int CDictQueue::SendDict_NOWAIT(CDict* pDict)
{
	return -1;
}

int CDictQueue::ReceiveDict(CDict* pDict)
{
		if(m_nQueueId == -1 || pDict == NULL)
			return -100;
		
		int nMsgLen,nDictLen;
		char* pRecvBuf = new char[MSGMAX];

		PINFO("ReceiveDict");
		if( (nMsgLen=ReceiveMsg(pRecvBuf,MSGMAX,MSGTYPE_DICT)) == -1)
		{

			delete[] pRecvBuf;
			return -1;
		}

		//长度不包含type，但数据内包含
		nDictLen = nMsgLen - sizeof(struct ncbs_msgdatabuf);
		
		PINFO("nMsgLen=%d,mtypelen=%d,mdlen=%d,nDictLen=%d",nMsgLen,sizeof(long), sizeof(struct ncbs_msgdatabuf),nDictLen);	

	
		struct ncbs_msgbuf head;
		memcpy(&head, pRecvBuf, sizeof(struct ncbs_msgbuf));
		
		if(nDictLen > 0)
		{
				DictHandle hDict = CDict::MallocHandle(nDictLen);
				memcpy(hDict,	pRecvBuf + sizeof(struct ncbs_msgbuf), nDictLen);
	/*		
				printf("Dict Data:");				
				for(int m=0;m<400;m++)
				{
					if(m%40 ==0)
						printf("\n");
					printf("%02x ",((char*)hDict)[m]);
						
				}
*/

				pDict->AttachHandle(hDict);

		}
		
		if(pRecvBuf)
			delete[] pRecvBuf;		

		return 0;
}

int CDictQueue::ReceiveDict_NOWAIT(CDict* pDict)
{

	return -1;
}

