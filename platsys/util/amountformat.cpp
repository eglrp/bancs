//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 技术平台公共类库
//  @ File Name : amountformat.cpp
//  @ Date : 2014/11/10
//  @ Author : disp
//
//


#include "amountformat.h"
#include <ctype.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <math.h>

CAmountFormat::CAmountFormat()
{


}

CAmountFormat::~CAmountFormat()
{

}

int CAmountFormat::ParseFormat(const char* szFormat,struct AFormat* pstFormat)
{
    //初始化输出pstFormat
    memset(pstFormat,0,sizeof(struct AFormat));
    //unsigned int nCompZero=0,nIntWidth=0,nPrecision=0;
    pstFormat->bDecimalPoint    =   false;
    pstFormat->nAddSign         =   AMOUNT_ADDSIGN_NULL;
   
    CString strFormat(szFormat);
    strFormat.Trim();
    strFormat.Remove(',');  //去除千分号
    strFormat.MakeUpper();  
 
    //校验Format合法性   
    if(strFormat.GetLength() < 2 || strFormat.Find('9')==-1 \
        || (strFormat.Find('V')==-1 && strFormat.Find('.')==-1) )
        return -1;
    
    int nFindS      = strFormat.Find('S');   
    int nFindDash   = strFormat.Find('-');            
    if( nFindS !=-1 && nFindDash !=-1 )
        return -1;
        
    //处理符号位
    if(nFindS != -1)
    {
        if(nFindS==0)
            pstFormat->nAddSign = AMOUNT_ADDSIGN_FRONT;
        else if(nFindS == strFormat.GetLength()-1)
            pstFormat->nAddSign = AMOUNT_ADDSIGN_REAR; 
        else
            pstFormat->nAddSign = AMOUNT_ADDSIGN_NULL;   
            
        strFormat.Remove('S');   
        //printf("[S]strFormat:%s\n",strFormat.c_str());                  
    }
    else if(nFindDash != -1)
    {
        if(nFindDash==0)
            pstFormat->nAddSign = AMOUNT_ADDSIGN_FRONTDASH;
        else if(nFindDash == strFormat.GetLength()-1)
            pstFormat->nAddSign = AMOUNT_ADDSIGN_REARDASH; 
        else
            pstFormat->nAddSign = AMOUNT_ADDSIGN_NULL;   
            
        strFormat.Remove('-');   
        //printf("[-]strFormat:%s\n",strFormat.c_str());         
    }
    else
    {
        pstFormat->nAddSign = AMOUNT_ADDSIGN_NULL;         
        
    }
           
    //处理(xx)，省略Z的情况,2014.11.19
    if(strFormat[0]=='(')
    {
        int nFindEZ=0;    
        int nFindEnd = strFormat.Find(')',nFindEZ);                                
        if( nFindEnd-nFindEZ == 3 || nFindEnd-nFindEZ == 4)   //(xx) (x)
        {
            strFormat = "Z"+strFormat;  //(xx) -> Z(xx)
        }
        else
            return -30;
    }
     
        
    //处理Z(xx)    
    int nFindZ = strFormat.Find("Z(");  
    if(nFindZ != -1)
    {
        if(nFindZ != 0) //Z格式有误，压缩必须优先在第一位
            return -2;  
                        
        int nFindEnd = strFormat.Find(')',nFindZ);
   
        if( nFindEnd-nFindZ == 3 || nFindEnd-nFindZ == 4)   //Z(xx) Z(x)
        {
            CString strCompZero = strFormat.Mid(nFindZ+2,nFindEnd-nFindZ-2);
            pstFormat->nCompZero = atoi(strCompZero.c_str());
            
            strFormat.Delete(nFindZ,nFindEnd-nFindZ+1);
            //printf("[Z]strFormat:%s\n",strFormat.c_str());
        }
        else    //Z格式有误，长度1或2位                    
            return -3;            
        
    }
    
    //处理，转换 '.' -> 'V'     
    int nFindP = strFormat.Find('.');  
    if(nFindP != -1)
    {
        pstFormat->bDecimalPoint = true;
        strFormat.Replace('.','V');
        //printf("[P]strFormat:%s\n",strFormat.c_str());         
    } 
    
    //999999V999  9(14)V999 9(12)99V99999
    int nFindV = strFormat.Find('V');  
    if(nFindV == -1)
        return -4;          
    else
    {
        //获取整数部分长度  
        CString strInt = strFormat.Left(nFindV);
        pstFormat->nIntWidth = CountNumNine(strInt);
        if(pstFormat->nIntWidth == -1)
            return -5;               
        
        //获取小数部分长度 
        CString strPre = strFormat.Right(strFormat.GetLength()-nFindV-1);
        pstFormat->nPrecision = CountNumNine(strPre);
        if(pstFormat->nPrecision == -1)
            return -6;                   
    } 
  
    return 0;      
    
}

int CAmountFormat::CountNumNine(CString& strFormat)
{
    //999999  9(14) 9(12)99
    int nCount1=0,nCount2=0;
    
    //处理9(xx)    
    int nFind = strFormat.Find("9(");  
    if(nFind != -1)
    {
        int nFindEnd = strFormat.Find(')',nFind);
   
        if( nFindEnd-nFind == 3 || nFindEnd-nFind == 4)   //9(xx) 9(x)
        {
            CString strTemp = strFormat.Mid(nFind+2,nFindEnd-nFind-2);
            nCount1 = atoi(strTemp.c_str());
            
            strFormat.Delete(nFind,nFindEnd-nFind+1);
        }
        else    //格式有误，长度1或2位                    
            return -1;            
        
    }
    
    //处理99999
    for(int n=0;n<strFormat.GetLength();n++)
    {
        char ch = strFormat[n];
        if( ch == '9')
            nCount2++;
        else if(ch == ' ' || ch == '\t')
            continue;
        else
            return -1;
        
    }
    
    return nCount1+nCount2;      
    
}  


CString CAmountFormat::ConvertD2S(double dAmount,const struct AFormat* pstFormat)
{
    
    //计算    
    int nFormatWidth = (pstFormat->nPrecision > 0) ? \
        (pstFormat->nIntWidth+pstFormat->nPrecision+1) : (pstFormat->nIntWidth+pstFormat->nPrecision);
    int nFormatPrecision = pstFormat->nPrecision;
    
    CString strAmount,strFormat;         
    strFormat.Format("%%0%d.%df",nFormatWidth,nFormatPrecision);
    strAmount.Format(strFormat.c_str(),fabs(dAmount) );
    
    //若超长，则右侧裁剪
    int nMaxLen = 0;
    if(pstFormat->nCompZero == 0)  //非压缩型
    {
        nMaxLen = nFormatWidth;
    } 
    else                            //压缩型Z
    {
        /*
        nMaxLen = (pstFormat->nPrecision > 0 ) ? \
            pstFormat->nCompZero + pstFormat->nIntWidth + pstFormat->nPrecision+1 :\
                 pstFormat->nCompZero + pstFormat->nIntWidth + pstFormat->nPrecision;
        */
        
        // nCompZero已经包含nIntWidth      
        nMaxLen = (pstFormat->nPrecision > 0 ) ? \
            pstFormat->nCompZero + pstFormat->nPrecision+1 :\
                 pstFormat->nCompZero  + pstFormat->nPrecision;
                 
                 
    } 
        
    if( nMaxLen > 0 )
        strAmount = strAmount.Right(nMaxLen);   
      
    //添加正负号
    CString strPlusSign = dAmount >= 0.0 ? "+" : "-";
    if(pstFormat->nAddSign == AMOUNT_ADDSIGN_FRONT ||\
         (pstFormat->nAddSign == AMOUNT_ADDSIGN_FRONTDASH && dAmount < 0.0))
        strAmount = strPlusSign + strAmount;    
    else if(pstFormat->nAddSign == AMOUNT_ADDSIGN_REAR ||\
         (pstFormat->nAddSign == AMOUNT_ADDSIGN_REARDASH && dAmount < 0.0)) 
        strAmount = strAmount + strPlusSign;    
           
    //删除小数点  
    if(pstFormat->bDecimalPoint == false)   
        strAmount.Remove('.'); 
    
    return strAmount;  
    
}

CString CAmountFormat::ConvertOutParam(double dAmount,const char* szFormat)
{
    CString strAmount;
    struct AFormat sf;
    int nRet = ParseFormat(szFormat,&sf);
    if( nRet == 0)
    {
        strAmount = ConvertD2S(dAmount,&sf);
        
    }
    //printf("ParseFormat nRet=%d\n",nRet);
    
    return strAmount;
    
    
}

double  CAmountFormat::ConvertS2D(const char* szAmount,const struct AFormat* pstFormat)
{

    CString strAmount(szAmount);
    strAmount.Trim();
    
    //校验长度
    int nLength = 0;        
    if(pstFormat->nCompZero == 0)   //非压缩
    {
        nLength = pstFormat->nIntWidth + pstFormat->nPrecision + \
            ( pstFormat->bDecimalPoint ? 1:0) + \
            ( pstFormat->nAddSign == AMOUNT_ADDSIGN_NULL ? 0:1); 
                    
        if(nLength <= 0 || strAmount.GetLength() != nLength)    //长度非法
            return 0.0;
    }
    else if(pstFormat->nCompZero > 0)
    {
        int nMin = pstFormat->nIntWidth + pstFormat->nPrecision + \
            ( pstFormat->bDecimalPoint ? 1:0) + \
            ( pstFormat->nAddSign == AMOUNT_ADDSIGN_NULL ? 0:1); 
        /*        
        int nMax = pstFormat->nCompZero + pstFormat->nIntWidth + pstFormat->nPrecision + \
            ( pstFormat->bDecimalPoint ? 1:0) + \
            ( pstFormat->nAddSign == AMOUNT_ADDSIGN_NULL ? 0:1); 
        */        
        // nCompZero已经包含nIntWidth            
        int nMax = pstFormat->nCompZero + pstFormat->nPrecision + \
            ( pstFormat->bDecimalPoint ? 1:0) + \
            ( pstFormat->nAddSign == AMOUNT_ADDSIGN_NULL ? 0:1); 
        
        nLength = strAmount.GetLength();
        if(nLength <= 0 || nLength < nMin || nLength > nMax)       //长度非法  
            return 0.0;
    }
    else
    {
        return 0.0;
    }
    
    //printf("nLength=%d\n",nLength);
            
    double dAmount=0.0;
    
    //调整正负符号的位置
    if(pstFormat->nAddSign == AMOUNT_ADDSIGN_REAR || pstFormat->nAddSign == AMOUNT_ADDSIGN_REARDASH)
    {
        if(strAmount[nLength-1] == '+' || strAmount[nLength-1] == '-')
        {
            CString strPlusSign = strAmount[nLength-1];
            strAmount.Remove(strAmount[nLength-1]);
            
            strAmount = strPlusSign + strAmount;
        }
        else if(pstFormat->nAddSign == AMOUNT_ADDSIGN_REAR)    //非法符号
            return 0.0;    
                        
    }
    
    //printf("strAmount:[%s]\n",strAmount.c_str());
    
    //添加小数点
    if( (pstFormat->nAddSign==AMOUNT_ADDSIGN_NULL && nLength >= pstFormat->nPrecision)\
        || nLength>=(pstFormat->nPrecision+1) )
    {
        if(pstFormat->bDecimalPoint==false &&pstFormat->nPrecision > 0)
            strAmount.Insert(nLength-pstFormat->nPrecision,".");
        
    }
    else    //非法精度
        return 0.0;

    
    //转换为double
    dAmount = atof(strAmount.c_str() );

    return dAmount;     
    
}

double  CAmountFormat::ConvertInParam(const char* szAmount,const char* szFormat)
{
    double dAmount=0.0;

    struct AFormat sf;
    if(ParseFormat(szFormat,&sf) == 0)
    {
        dAmount = ConvertS2D(szAmount,&sf);
        
    }
    
    return dAmount;
    
    
}

