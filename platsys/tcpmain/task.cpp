//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 技术平台公共类库
//  @ File Name : task.cpp
//  @ Date : 2013/8/28
//  @ Author : disp
//
//


#include "task.h"
#include "appbase.h"

CMintcpio  CTask::m_tcpio;
    
CTask::CTask():m_mqm(true)
{
	m_dictIn.InitDict(10);	
	m_dictOut.InitDict(10);		
	m_bWSEndFlag = false;
	m_bWSLastMessage = true;
}

CTask::CTask(int socket):m_mqm(true)
{
    m_tcpio.SetClientSD(socket);
	m_dictIn.InitDict(10);	
	m_dictOut.InitDict(10);		
	m_bWSEndFlag = false;
	m_bWSLastMessage = true;
}

CTask::~CTask()
{
	m_dictIn.DestroyDict();
	m_dictOut.DestroyDict();	
	m_mqm.RemoveTrmQ();       //删除已经建立的输出队列
}

void CTask::SignalCleanup(int sig)
{
    /* turn off signals */
    sighold(SIGINT);
    sighold(SIGQUIT);
    sighold(SIGHUP);
    sighold(SIGPIPE);

    signal(SIGINT,SIG_IGN);
    signal(SIGQUIT,SIG_IGN);
    signal(SIGHUP,SIG_IGN);
    signal(SIGPIPE,SIG_IGN);	//写至无读进程的管道

    switch (sig)
    {
    case SIGINT:
    case SIGQUIT:
    case SIGHUP:
    case SIGPIPE:
        /* reset handle to signalclean up */
        signal(sig, CTask::SignalCleanup);
        PINFO ("Received signal %d and ignoring it\n",sig);
        break;
    default:
        PINFO("Signal %d caught and aborting\n",sig);
        m_tcpio.Finish();
        //exit(1);
    }

    /* turn on signals */
    sigrelse(SIGINT);
    sigrelse(SIGQUIT);
    sigrelse(SIGHUP);
    sigrelse(SIGPIPE);

}


int CTask::C000_PREPROCESS()
{
/*
	C000_PREPROCESS.
	1、接收网络请求报文数据；					（MINTCPIO 2,若socket err，则m_bWSEndFlag=true）
	2、依据pid来创建TERMQxxx输出报文消息队列；	（三步：z100_ENABLE-INPUT-TERMQ, z300_DISABLE-TERMQ, z100_ENABLE-INPUT-TERMQ）
	3、获取请求报文的交易码；					（UT9005）
	4、依据交易码，构建其对应APPQ的名称；		（STRING UT9005CA-SYSTEM-NAME (1) "Q" ）
	5、检查日夜模式；							（CHECK FOR NIGHT OR DAY MODE： UT0008CA-24HR-REGION）
	6、依据日夜模式来构建APPQ消息队列；			（Z200_ENABLE-OUTPUT-APPQ）
*/
	 
	PDEBUG("开始接收网络数据\n");	
	            	
    //byte MsgData[sizeof(TCP_HEADER)+sizeof(MINTCPIO_DATA)];
	memset(m_MsgData,0,sizeof(TCP_HEADER)+sizeof(MINTCPIO_DATA));
	m_nMsgDataLen=0;
	
	if(m_tcpio.ReadMsg(m_MsgData,&m_nMsgDataLen) !=0)    //接收网络数据
	{
        PERROR("CMintcpio::ReadMsg() call failed: %s\n", strerror(errno));	
        m_bWSEndFlag = true;
		return -1;
	}
	
	PDEBUG("开始建立输出队列TrmQ\n");	
		
	if(m_mqm.CreateTrmQ()!=0)  //输出队列，若存在则先删除，并重新创建MQ
	{
        PERROR("CMqManage::CreateAppQ() call failed: %s\n", strerror(errno));	
		m_bWSEndFlag = true;
		Z400_TCP_MSG(Z400_TYPE_C000ETERMQ);
		return -1;
	}	
	PDEBUG_D("  TRMQ Key=0x%X\n",m_mqm.GetTrmQKey() );

	PDEBUG("开始解包（msglen:%d）\n",m_nMsgDataLen);
   
    m_dictIn.ClearDict();
	m_pkgUpackHeader.SetDict(&m_dictIn);
	m_pkgUpackHeader.SetMsg((char*)m_MsgData);
	m_pkgUpackHeader.SetMsgLen(m_nMsgDataLen);
	int nAutoAddLF = GetLogAutoAddLF();
    SetLogAutoAddLF(1);
    int nRet = m_pkgUpackHeader.DoProcessInHeader();
    SetLogAutoAddLF(nAutoAddLF);  
         
    if( nRet != 0) //Msg -> Dict
	{
        PERROR("输入报文解包失败\n");	
		//m_bWSEndFlag = true;
		Z400_TCP_MSG(Z400_TYPE_C000APPPARAM);		
		return -1;	
	}
    		
	int nTranCode = m_pkgUpackHeader.GetTranCode();
	if(nTranCode <= 0)
	{
        PERROR("输入报文交易码非法（%06d）\n",nTranCode);	
		//m_bWSEndFlag = true;
		Z400_TCP_MSG(Z400_TYPE_C000APPPARAM);	
		return -1;			    
	}	    
	PDEBUG("输入报文拆包成功，交易码: %06d\n",nTranCode);	

	
	PDEBUG("开始建立输入队列AppQ\n");	
			
	if(m_mqm.CreateAppQ(nTranCode)!=0)  //输入队列，若存在则使用，否则创建新MQ
	{
       PERROR("CMqManage::CreateAppQ() call failed: %s\n", strerror(errno));	
		m_bWSEndFlag = true;
		Z400_TCP_MSG(Z400_TYPE_C000EAPPQ);		
		return -1;
	}
	
	return 0;    
}
    
int CTask::D000_SEND()
{
/*
	//D000_SEND
	1、构建DELHEADER报文头；					（WS-SEND-DEL-HEADER：WS-SEND-DEL-RESPONSEQ、WS-SEND-DEL-MSG-SEQUENCE）
	*2、UT0003不知在找什么？
	3、将构建的报文发送至相应的消息队列APPQ；	（使用阻塞QUEIO->SEND ？）
*/
	
	//NCBS_QUEIO queio_in;
	memset(&queio_in,0,sizeof(NCBS_QUEIO));
	queio_in.mtype = MSGTYPE_NORMAL;
	
	//构建DELHEADER报文头；
	char szTemp[64+1]="";		
	queio_in.data.del_header.source_system = 'U';
	sprintf(szTemp,"%08d",getpid());    strncpy((char*)queio_in.data.del_header.process_id,szTemp,8);
	sprintf(szTemp,"%09d",1);           strncpy((char*)queio_in.data.del_header.msg_sequence,szTemp,9);
	
	PDEBUG("构建DELHEADER报文头，process_id=[%s]\n",(char*)queio_in.data.del_header.process_id);	
		
	//赋值msgdata；	
	memcpy(	queio_in.data.msg_data,	m_MsgData, m_nMsgDataLen);		
	
	PDEBUG("开始发送数据到输入队列APPQ\n");	
	
	//将构建的消息发送至相应的APPQ
	CQueue *pAppQ = m_mqm.GetAppQueue();
	if( pAppQ->SendMsg_NOWAIT( &queio_in, sizeof(NCBS_QUEIO_DATA)) < 0)
	{
        PERROR("CQueue::SendMsg_NOWAIT() call failed: %s\n", strerror(errno));	
	    Z400_TCP_MSG(Z400_TYPE_D000SAPPQ);	
		return -1;		    
	}
	
	//记录原始的输入报文日志
	COMLOG("[IN ]%s\n\n",(char*)queio_in.data.msg_data);
	
	return 0;    
}

int CTask::E000_RECEIVE()
{
/*
	//E000_RECEIVE
    1、设定开始时间，用于计算超时？				（SAVE THE START TIME：UT1996）
    2、从TERMQ接收返回报文; 					（使用超时QUEIO->RECEIVE_TIME ？）
    3、检验返回报文的合法性；
    	（1）接收报文出错，Z400 ；		IF QUEIO-STATUS-KEY NOT = "00"
    	（2）无数据，Z400 ；			IF QUEIO-CA-NO-DATA,msgrcv timeout
    	（3）交易码非数字；				IF WA-INT-TCODE NOT NUMERIC
    	（4）序列号校验失败；			IF WA-SAVE-SEQ-NO NOT = WA-RECV-DEL-MSG-SEQUENCE
    	（5）响应超时，Z400 ；			IF WA-TURN-AROUND-TIME > WA-TIMEOUT-FRONT-END-SECS
    	
    4、INTHEADER中的FLAG2，判断是否有后续包；			
    5、发送网络应答报文数据							（MINTCPIO 3）
    6、若WS-LAST-MESSAGE==true则退出E000_RECEIVE;	（WS-LAST-MESSAGE，在出错Z400或无后续包的情况下为true）
*/

     
    //设定开始时间   
    CUtilMisc::GetTimeInterval(0);
        
    //NCBS_QUEIO queio_out;
    memset(&queio_out,0,sizeof(NCBS_QUEIO));
    queio_out.mtype = MSGTYPE_NORMAL;	
    
    PDEBUG("开始从TRMQ读取数据\n");
    
    CQueue *pTrmQ = m_mqm.GetTrmQueue();		    	    
    if( pTrmQ->ReceiveMsg_TIME( &queio_out, sizeof(NCBS_QUEIO_DATA),TIMEOUT_Q) < 0)    //30秒超时
    {
        PERROR("CQueue::ReceiveMsg_TIME() call failed: %s\n", strerror(errno));	
	    Z400_TCP_MSG(Z400_TYPE_E000BADREC);	
	    return -1;
    }			
    
    if(queio_out.data.msg_data[0] == '\0')
    {
        PERROR("接收TRMQ数据超时\n");	
	    Z400_TCP_MSG(Z400_TYPE_E000QTIMEOUT);	
	    return -1;
    }
    
    m_dictOut.ClearDict();
	m_pkgUpackHeader.SetDict(&m_dictOut);
	m_pkgUpackHeader.SetMsg((char*)queio_out.data.msg_data);
	m_pkgUpackHeader.SetMsgLen(strlen((char*)queio_out.data.msg_data));
    SetLogAutoAddLF(1);
    int nRet = m_pkgUpackHeader.DoProcessOutHeader();
    SetLogAutoAddLF(0);            
    if(nRet != 0) //Msg -> Dict
	{
        PERROR("输出报文解包失败\n");	
		return -1;	
	}
    int nTranCode = m_pkgUpackHeader.GetTranCode();
	if(nTranCode <= 0)
	{
        PERROR("输出报文交易码非法（%06d）\n",nTranCode);	
		return -1;			    
	}
	if(memcmp(queio_in.data.del_header.msg_sequence,queio_out.data.del_header.msg_sequence ,9) != 0)
	{
        PERROR("序列号校验失败\n");	
		return -1;		    
 	}	
 	if( CUtilMisc::GetTimeInterval(1)/(1000*1000) > TIMEOUT_S)
 	{
        PERROR("处理响应超时\n");	
	    Z400_TCP_MSG(Z400_TYPE_E000STIMEOUT);	
	    return -1;	    
 	}
 	
     PDEBUG("开始将数据发送至请求方\n");
    
    //检查INTHEADER中的FLAG2，判断是否有后续包，并设置m_bWSLastMessage
    m_bWSLastMessage = m_pkgUpackHeader.CheckLastMsg()==1 ? true:false;
    

    //将输出报文发送给请求方	
	byte* pMsgOut = queio_out.data.msg_data;	
		        		    
	if( m_tcpio.WriteMsg(pMsgOut,strlen((char*)pMsgOut) ) < 0 )
	{
        PERROR("CMintcpio::WriteMsg() call failed: %s\n", strerror(errno));	
        //m_bWSEndFlag = true;
        //
        
		return -1;			    
	}
	
	PDEBUG("成功发送数据\n");
	
	//记录原始的输出报文日志
    COMLOG("[OUT]%s\n\n",(char*)pMsgOut);

    return 0;    
}

  
int CTask::Z400_TCP_MSG(int type)
{
    PDEBUG("Z400_TCP_MSG type=%d \n",type);	
    
    m_bWSLastMessage = true;
    
    CString strTemp;
    switch(type)
    {
        case Z400_TYPE_C000ETERMQ:
            strTemp.Format("01ERR 0155 00 %s CANNOT ENABLE TERMQ",CAppBase::GetAppName());
            break;
        
        case Z400_TYPE_C000APPPARAM:
            strTemp.Format("01ERR 0155 00 BAD FORMAT.");            
            break;
        
        case Z400_TYPE_C000EAPPQ:
            strTemp.Format("01ERR 0155 00 ""APPLICATION NOT ACTIVE."); 
            break;
         
        case Z400_TYPE_D000MAXT:
            //sprintf(szTemp,"01ERR 0155 00 %s MAXIMUM TRANSACTION FOR THIS APPLICATION EXCEEDED. PLEASE TRY AGAIN.",m_mqm.GetAppQName().c_str());
            strTemp.Format("01ERR 0155 00 %s MAXIMUM TRANSACTION FOR THIS APPLICATION EXCEEDED.",m_mqm.GetAppQName().c_str());
            break;           
         
        case Z400_TYPE_D000SAPPQ:
            strTemp.Format("01ERR 0155 00 ERROR SENDING TO %s ",m_mqm.GetAppQName().c_str());
            break;           
         
        case Z400_TYPE_E000BADREC:
            strTemp.Format("01ERR 0155 00 BAD RECEIVE FROM LINKOUT.");
            break;           
          
        case Z400_TYPE_E000QTIMEOUT:
             //sprintf(szTemp,"01ERR 0155 00 HOST TIME-OUT OCCURRED FOR TXN CODE %06d. PLS INQUIRE IF TXN IS COMPLETED AT HOST.", m_pkgUpackHeader.GetTranCode());
             strTemp.Format("01ERR 0155 00 HOST TIME-OUT OCCURRED FOR TXN CODE %06d.", m_pkgUpackHeader.GetTranCode());
             break;          
         
        case Z400_TYPE_E000STIMEOUT:
             strTemp.Format("01ERR 0155 00 OUT-OF-SYNC MSG. REPORT TIME/DATE & CONTINUE NORMALLY.");
             break;
         
        case Z400_TYPE_E000APPPARAM:
        default:
            strTemp.Format("01ERR 0155 00 BAD PARAM.");             
            break;

        }
        
    char szTemp[1024]="";
    sprintf(szTemp,"%-79s",strTemp.c_str());
    
    byte data[sizeof(MINTCPIO_DATA)];    
    memcpy(data,&(m_MsgData[sizeof(TCP_HEADER)]),INT_HEADER_SIZE);
    memcpy(&(data[INT_HEADER_SIZE]),szTemp,strlen(szTemp));
        
 	if( m_tcpio.Write((MINTCPIO_DATA*)data,INT_HEADER_SIZE+strlen(szTemp) ) < 0 )
	{
        PERROR("CMintcpio::Write() call failed: %s\n", strerror(errno));	
		return -1;			    
	}

    return 0;
    
}