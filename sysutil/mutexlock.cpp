//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 技术平台公共类库 基于信号量的互斥锁
//  @ File Name : mutexlock.cpp
//  @ Date : 2013/6/20
//  @ Author : disp
//
//

#include "platspub.h"
#include "mutexlock.h"

CMutexLock::CMutexLock()
{
	m_nSemId = -1;
}

CMutexLock::~CMutexLock()
{

}

int CMutexLock::Create(key_t key)
{
		int nSemId = semget(key,1,0660|IPC_EXCL|IPC_CREAT);
		if(nSemId == -1)
		{
				PINFO("create MutexLock error: %s", strerror(errno));		
			
		}
		else
		{
				union semun semopts;
				semopts.val = 1;
				semctl(nSemId,0,SETVAL,semopts); 			
		}
				
		m_nSemId = nSemId;
		return nSemId;
}

int CMutexLock::Select(key_t key)
{
		int nSemId = semget(key,1,0);
		if(nSemId == -1)
		{
				PINFO("select MutexLock error: %s", strerror(errno));		
			
		}
		
		m_nSemId = nSemId;
		return nSemId;
}
/*
		struct timespec{  
		    time_t tv_sec; //秒s
		    long tv_nsec; 	//纳秒ns 
		}; 
		int semtimedop(int semid, struct sembuf *sops, unsigned nsops, struct timespec *timeout);
		int semop			(int semid, struct sembuf *sops, unsigned nsops);
*/

int CMutexLock::Lock() //P
{
		if(m_nSemId==-1)
			return -100;
			
		struct sembuf sbuf;
		sbuf.sem_num = 0;
		sbuf.sem_op = -1;
		sbuf.sem_flg = SEM_UNDO; //sbuf.sem_flg & ~IPC_NOWAIT)
		return semop(m_nSemId,&sbuf,1);
		

}

int CMutexLock::Unlock()	//V
{
		if(m_nSemId==-1)
			return -100;
			
		struct sembuf sbuf;
		sbuf.sem_num 	= 0;
		sbuf.sem_op 	= 1;
		sbuf.sem_flg	= SEM_UNDO; //sbuf.sem_flg & ~IPC_NOWAIT)
		return semop(m_nSemId,&sbuf,1);
}

int CMutexLock::TryWait(int block)	//Z
{
		if(m_nSemId==-1)
			return -100;
			
		struct sembuf sbuf;
		sbuf.sem_num 	= 0;
		sbuf.sem_op 	= 0;
		sbuf.sem_flg 	= (block ? SEM_UNDO : SEM_UNDO|IPC_NOWAIT);
		return semop(m_nSemId,&sbuf,1);			
}

int CMutexLock::Destroy()
{
		if(m_nSemId==-1)
			return -100;
			
		return semctl(m_nSemId,0,IPC_RMID);
			
}

