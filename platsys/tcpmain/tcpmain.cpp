//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 技术平台公共类库
//  @ File Name : tcpmain.cpp
//  @ Date : 2013/8/15
//  @ Author : disp
//
//

#include "tcpmain.h"
#include "syscfg/syse.h"
#include "task.h"
   
int main (int argc, char *argv[])
{
	InitLoger(NULL,LOGLEVEL_DEBUG,1);
	
    CTcpMain app;

    return app.Run(argc, argv);
}


bool CTcpMain::m_bMPWSEndFlag 	= false;
	
CTcpMain::CTcpMain()
{
	m_nCmdType = -1;
	m_bDaemon = false;
	m_nListenPort = CSyse::GetTcpListenPort();
	
	m_client_sd = -1;
}

CTcpMain::~CTcpMain()
{

}

void CTcpMain::ShowHelp()
{
    cout<<endl;
	cout<<"Usage: "<< GetAppName() <<"  [start|stop|restart]  [-v|-d|-port:<port number>]"<<endl; 
    cout<<endl;
    cout<<"         start                    Start the process.                   "<<endl; 
	cout<<"         stop                     Stop the process of running.         "<<endl;
	cout<<"         restart                  Restart the process.                 "<<endl;	 
	cout<<"         -v                       Dislay help information.             "<<endl; 
	cout<<"         -d                       Make the process as a deamon.        "<<endl;
	cout<<"         -port:<port number>      Specify port number of listen.       "<<endl;

    cout<<endl;	
	cout<<"Examples:"<<endl;
	cout<<"         (1) Start the tcpmain, type: tcpmain start   "<<endl;	
	cout<<"         (2) Start the tcpmain as a deamon, type: tcpmain start -d   "<<endl;	
	cout<<"         (3) Stop the tcpmain, type: tcpmain stop   "<<endl;	
	cout<<"         (4) Restart the tcpmain, type: tcpmain restart   "<<endl;	
	cout<<"         (5) Restart the tcpmain as a deamon, type: tcpmain restart -d   "<<endl;		   
	cout<< endl;
}

void CTcpMain::SignalCleanup(int sig)
{
   switch(sig)
    {
        case SIGTERM:
        case SIGINT:
			{
				m_bMPWSEndFlag = true;
			}
			break;
        default:
            break;;          
    }
    
    	
}

int CTcpMain::PreProcess(int argc, char *argv[])
{
	CAppBase::PreProcess(argc,argv);

	for(int n=1;n<argc;n++)
	{
		CString strArg=argv[n];
		strArg.Trim();
		if(strArg.Find("-version") != -1 || strArg.Find("-v") != -1)
		{
			ShowVersion();
			ShowHelp();
			return -1;
		}
		else if(strArg.Find("restart") != -1)
		{
			m_nCmdType = CMD_RESTART;
		}			
		else if(strArg.Find("start") != -1)
		{
			m_nCmdType = CMD_START;
		}
		else if(strArg.Find("stop") != -1)
		{
			m_nCmdType = CMD_STOP;
		}

		else if(strArg.Find("-daemon") != -1 || strArg.Find("-d") != -1)
		{
			m_bDaemon = true;
		}				
		else if(strArg.Find("-port:") != -1)
		{
		    //检查设置的监听端口是否有效
			int len = strArg.GetLength();
			int m = strlen("-port:");
			if(len >= m+4) //port > 1024 
			{
				CString temp = strArg.Right(len-m);
				temp.Trim();
				if(atoi(temp.c_str()) > 1024)
					m_nListenPort = atoi(temp.c_str());
				
			}
		}
		else 
		{
			cout<< "Invalid option" << endl;
			cout<< "Try `-v' for more information." << endl;
			return -1;
		}

	}//end for
		
	
    m_Mutex.SetMutexFile("./.tcpmain.running");
    
    
    switch(m_nCmdType)
    {
        case CMD_START:
            break;
            
        case CMD_STOP:
            {
                if(!m_Mutex.KillProcess())
                {
                    PDEBUG_D("Error: Don't kill the tcpmain.\n"); 
                    //PDEBUG_D("%s\n",m_Mutex.GetErrorStr().c_str());
                }         
                return -1;
            }
            break;
            
        case CMD_RESTART:
            {
                if(!m_Mutex.KillProcess())
                    PDEBUG_D("Error: Don't find the tcpmain.\n");      
                         
                sleep(2);
            }
            break;
            
       default:
            {
    			ShowVersion();
    			ShowHelp();
    			return -1;    
            }       
    }
          	
	return 0;
}

int CTcpMain::Process()
{
	//PDEBUG_D("UserName:      %-20s	(uid=%d)\n",GetUserName(),getuid());
	//PDEBUG_D("GroupName:     %-20s	(gid=%d)\n",GetGroupName(),getgid());
	PDEBUG_D("AppParentName: %-20s	(pid=%d)\n",GetAppName(),getpid());
	
	int nRet = 0;
	
	if(m_bDaemon)	//转为守护进程
	{
		nRet = MakeMPDaemon();
		if(nRet != 0)
			return nRet;
		
	}

    if(!m_Mutex.InitMutex())    //检查是否运行
    {
        //PDEBUG_D("%s\n",m_Mutex.GetErrorStr().c_str());
        PDEBUG_D("The %s has been running already.\n",GetAppName());
        return 1;
    }
  
 	if(m_bDaemon)	
	{  
 		PDEBUG_D("AppChildName:  %-20s	(pid=%d)\n",GetAppName(),getpid());
        PDEBUG_D("The %s is running as a DAEMON.\n",GetAppName());	
        
        if(setsid()<0)
            return -1;
            
        int fd = open("/dev/null",O_RDWR,0);
        if(fd!=-1)
        {
            dup2(fd,STDIN_FILENO);
            dup2(fd,STDOUT_FILENO);
            dup2(fd,STDERR_FILENO);
            close(fd);
        }                   	    	
         
    }   
   
	PDEBUG_D("-------------------------------------------------------\n");
	PDEBUG_D("Start service...\n");	
	
    if(CMqManage::InitCfg()==-1)
    {
        PDEBUG("装载APPC失败\n");	        
        return -1;
    }
	
	nRet = DoService();		//开始服务主循环，侦听网络，接受连接请求
	switch(nRet)
	{
		case RET_OK:
			nRet = ProcessRequest();
			PDEBUG_D("Child process exit.\n" );
			break;
			
		case RET_BAD:
			PDEBUG_D("DoService() returned : RET_BAD\n");
			break;
			
		case RET_MPEXIT:
		    PDEBUG_D("Main process exit.\n" );
		    break;
		    
		default:
			break;
	}
			
	return nRet;
	
}

int CTcpMain::Finish(int nProcess)
{
	CAppBase::Finish(nProcess);
		
	
	return 0;
}

int CTcpMain::MakeMPDaemon()
{
	//将主进程转换至后台守护进程
	/*
	//忽略相关信号 
    signal(SIGCHLD,SIG_IGN);	//子进程状态改变（避免zombie产生）
    signal(SIGHUP,SIG_IGN);		//终端连接断开，（终端的控制进程结束）
    signal(SIGINT,SIG_IGN);		//终端中断符，	（通常是Ctrl-C）
    signal(SIGQUIT,SIG_IGN);	//终端退出符，	（通常是Ctrl-\）
    signal(SIGTERM,SIG_IGN);	//程序结束信号，（命令kill缺省产生）
	*/
	
	int pid = fork();
	switch (pid)
	{
	case -1:
	    PERROR_D("Cant create new process: %d: %s\n", errno, strerror(errno));
	    break;
	    
	case 0:     /* Child process */

	    signal(SIGCHLD,SIG_IGN);
	    signal(SIGHUP,SIG_IGN);
	    signal(SIGINT,SIG_IGN);
	    signal(SIGQUIT,SIG_IGN);
	    signal(SIGTERM,CTcpMain::SignalCleanup);
	

  	   	//close(STDIN_FILENO);
       	//close(STDOUT_FILENO);
       	//close(STDERR_FILENO);  
       	 	        	
	    break;
	
	default:    /* Parent process  */
	    //CUtilMisc::Sleep(1,0);
	    	
	    break;
	}	
	
	return pid;	
	
}

int CTcpMain::DoService()
{
    if(! m_bDaemon)
    {
    	//忽略相关信号，可以通过nohup &转为后台
        signal(SIGCHLD,SIG_IGN);
        signal(SIGHUP,SIG_IGN);	
        signal(SIGQUIT,SIG_IGN);
        signal(SIGINT,CTcpMain::SignalCleanup);	   
        signal(SIGTERM,CTcpMain::SignalCleanup);
    }
           
    int listen_sd = socket( AF_INET, SOCK_STREAM, 0 );
    
    if ( listen_sd < 0 ) 
    {
        PERROR_D("Socket() call failed: %s\n", strerror(errno));
        return RET_BAD;
    }

    PDEBUG_D("Socket() returned %d\n", listen_sd );

    int optval = 1;
    int rc = setsockopt(listen_sd,SOL_SOCKET,SO_REUSEADDR,&optval,sizeof(optval));	//设置端口重用
    if ( rc < 0 ) 
    {
       PERROR_D("Setsockopt() REUSEADDR call failed: %s\n", strerror(errno));
       close( listen_sd );
       return RET_BAD;
    }
    
   	struct sockaddr_in server_addr, client_addr;        
         
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = m_nListenPort;
    server_addr.sin_addr.s_addr = INADDR_ANY;
            
    rc = bind( listen_sd, (struct sockaddr *) &server_addr, sizeof( server_addr ) );
    if ( rc < 0 ) 
    {
        PERROR_D("Bind() call failed: %s\n", strerror(errno));
        close( listen_sd );
        return RET_BAD;
    }
    
    PDEBUG_D("Bind() call returned %d\n", rc );
    PDEBUG_D("Server will listen on port %d\n", ntohs( server_addr.sin_port ) );

    rc = listen( listen_sd, 32 );
    if ( rc < 0 ) 
    {
        PERROR_D("Listen() call failed: %s\n", strerror(errno));
        close( listen_sd );
        return RET_BAD;
    }

    PDEBUG_D("Listen() call returned %d\n", rc );
    PDEBUG_D("Accept() waiting for an incoming connection...\n" );
    
    do 
    {
    	if(m_bMPWSEndFlag)
        	break;
    	
        unsigned int len = sizeof( struct sockaddr_in );
        int sd = accept( listen_sd, (struct sockaddr *) &client_addr, &len );
        if ( sd < 0 ) 
        {
            PERROR_D("Accept() call failed: %d: %s\n", errno, strerror(errno));
	    	sleep(1);	/* This is to stop us looping too fast on error*/
	    	continue;
        }
        
         PDEBUG_D("sd=%d\n", sd);
                   
		int pid = fork();
        switch (pid) 
        {
        case -1:
            PERROR_D("Cant create new process: %d: %s\n", errno, strerror(errno));
		    sleep(1);	/* This is to stop us looping too fast on error*/
		    break;
		    
        case 0:     /* Child process */
        {
            close( listen_sd );

			signal(SIGCHLD,SIG_IGN);
			signal(SIGHUP,SIG_IGN);
			signal(SIGINT,SIG_IGN);
			signal(SIGQUIT,SIG_IGN);
			signal(SIGTERM,CTask::SignalCleanup);
			
			/*
			// Save the IP address for COBOL
			sprintf(ipaddr_tmp,"%16.16s",inet_ntoa(client_addr.sin_addr));
			memcpy((char *)area->ipaddr,ipaddr_tmp,16);
			
			 // Save the client name (from /etc/hosts) for COBOL 
            host = gethostbyaddr((char *)&client_addr.sin_addr,
                                 sizeof(struct in_addr),
                                 client_addr.sin_family);
            if (host == NULL) {
               sprintf(host_tmp,"Unknown client  \0");
            } else {
               sprintf(host_tmp,"%16.16s",host->h_name);
            }
            memcpy((char *)area->hostname,host_tmp,16);
			*/

            pid = getpid();
            
            char ipaddr_tmp[17];
  			char host_tmp[17];
  			sprintf(ipaddr_tmp,"%16.16s",inet_ntoa(client_addr.sin_addr));
            struct hostent *host = gethostbyaddr((char *)&client_addr.sin_addr,sizeof(struct in_addr), client_addr.sin_family);
             if (host == NULL)
               sprintf(host_tmp,"Unknown client  \0");
            else
               sprintf(host_tmp,"%16.16s",host->h_name);		
               	
			PDEBUG_D("=======================================================\n" );
			PDEBUG_D("Started new MINTCPSV task. PID=%d \n", pid );
			PDEBUG_D("Established connection with %s:%s \n", ipaddr_tmp, host_tmp );
			PDEBUG_D("=======================================================\n" );

	 	   	close(STDIN_FILENO);
	       	close(STDOUT_FILENO);
	       	close(STDERR_FILENO); 

 			/* Set the OOBINLINE flag for the socket so data stays in order */
            optval = 1;
            rc = setsockopt(sd,SOL_SOCKET,SO_OOBINLINE,&optval,sizeof(optval));
            if ( rc < 0 ) 
            {
                PERROR_D("Setsockopt() call failed: %s(errno=%d)\n", strerror(errno),errno);
                close( sd );
                return RET_BAD;
            }
            
			m_client_sd = sd;
			
            return RET_OK;
		}
        default:    /* Parent process - wait for next connection */
            close( sd );
            break;
            
        }//end switch fork
        
        
    } while (1);

	if(listen_sd != -1)
		close(listen_sd); 
       	
	return RET_MPEXIT;
}

int CTcpMain::ProcessRequest()
{
/*	
002570      PERFORM UNTIL WS-END-FLAG
002580         PERFORM C000-PREPROCESS THRU C000-EXIT
002590         IF  NOT WS-END-FLAG
SONNY3         AND NOT WS-LAST-MESSAGE
002610            PERFORM D000-SEND    THRU D000-EXIT
002620            PERFORM E000-RECEIVE THRU E000-EXIT
002630                    UNTIL WS-LAST-MESSAGE
002640         END-IF
002650      END-PERFORM.
*/
    
	CTask* pTask = new CTask(m_client_sd);
    pTask->SetEndFlag(false);
    
	while(1)
	{
		if(pTask->GetEndFlag())
		{
            PDEBUG("EndFlag=true，将要退出子进程的循环\n");		    
		    break;
		}
		
		PDEBUG("开始处理C000-PREPROCESS()\n");	
		if(pTask->C000_PREPROCESS()!=0)
		    continue;
		    
		PDEBUG("开始处理D000-SEND()\n");			    
		if(pTask->D000_SEND()!=0)
		    continue;	
	
		PDEBUG("开始循环处理E000-RECEIVE\n");	
	    pTask->SetLastMsgFlag(true);	            		
		do
		{
 		    if(pTask->E000_RECEIVE()!=0)
    		{
                PDEBUG("输出报文合法性检验未通过\n");		    
      		}
			
		}while(! pTask->GetLastMsgFlag());


	}//end while	
	
    delete pTask;	
	
	return 0;
}




